Struttura:
psblas:
psblas/src: la directory contenente il codice sorgente
psblas/src/comm: contiene tutte le routine preposte allo scambio di
		 dati 
psblas/src/internals: contiene una serie di routine utilizzate per
		 l'assemblaggio dei descrittori di comunicazione e per
		 lo scambio di dati (psi_dswap_data e psi_dswap_tran)
psblas/src/methd: contiene l'implementazione dei metodi iterativi
psblas/src/modules: contiene i moduli con le interfacce, le
		 definizioni di tipi e di costanti
psblas/src/prec: contiene tutte le routine preposte alla generazione e
		 applicazione dei precondizionatori
psblas/src/psblas: contiene le routine algebriche parallele
psblas/src/serial: contiene l'implementazione seriale di routine
		 algebriche e ausiliarie
psblas/src/serial/aux: routine ausiliarie (in realtà c'è rimasto be poco)
psblas/src/serial/coo: routine relative al formato coo
psblas/src/serial/csr: routine relative al formato csr
psblas/src/serial/dp: routine per l'assemblaggio e la conversione da
		 un formato all'altro
psblas/src/serial/f77: si tratta delle routine algebriche. queste
		 vengono chiamate all'interno delle routine in
		 psblas/src/psblas. 
psblas/src/serial/jad: routine relative al formato jad
psblas/src/tools: tutte le routine per la generazione e rigenerazione
		 di descrittori e matrici
psblas/test: programmi di test


Schema di nomenclatura:
tutti i simboli (quindi routine, tipi dato, costanti, moduli etc...)
devono avere il prefisso psb_. I tipi hanno il suffisso "_type" (quindi
quello che prima era d_spmat adesso diventa psb_dspmat_type), tutti i
moduli hanno il suffisso "_mod".


Interfacce subroutine & argomenti:
l'articolo di Carney et al. richiede questa convenzione per l'ordine
degli argomenti:
1-  arguments specifying options (tipo TRANS, UNITD etc...)
2-  arguments specifying problem dimensions
3-  input scalar associated with input matrices
4-  description of sparse input matrices (che sarebbe i nostri FIDA e
    DESCRA)
5-  description of dense input matrices
6-  input scalar associated with input-output matrices
7-  description of input-output matrices
8-  error processing informations
9-  workspace
10- length of workspace

tutto questo va rivisto nell'ottica f90 e, quindi, con i tipi dato
user-defined e con gli argomenti opzionali.
Attualmente, in linea di massima, le interfacce delle routine
algebriche hanno sempre desc_a (il descrittore) e info (il codice di
errore riportato) nelle ultime posizioni prima dei parametri
opzionali. I parametri opzionali contengono sempre gli argomenti al
punto 1 oltre che jx, jy e k che definiscono il sottopreblema su cui
effettuare l'operazione richiesta. Per tutto il resto non c'è uno
schema ben definito e viene, generalmente seguito l'ordine con cui gli
operandi appaiono nella scrittura della formula matematica relativa
all'operazione implementata nella subroutine. si potrebbe pensare a
come risistemare la cosa ma secondo me è abbastanza chiara.









